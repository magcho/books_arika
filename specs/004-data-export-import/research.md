# Research: データエクスポート・インポート機能

**Created**: 2025-01-27  
**Feature**: データエクスポート・インポート機能  
**Purpose**: 技術的な決定事項と実装アプローチの文書化

## 技術的決定事項

### 1. JSONファイル構造設計

**Decision**: 階層構造のJSON形式を採用。メタデータ、書籍データ、場所データ、所有情報を明確に分離する。

**Rationale**: 
- データの可読性と保守性を確保
- 将来のスキーマ拡張に対応しやすい
- 他の読書管理サービスへの移行時に変換しやすい

**Alternatives considered**:
- フラット構造: 可読性が低く、関係性が不明確
- XML形式: JSONより冗長で、パースが重い

**Implementation**:
```json
{
  "version": "1.0",
  "exported_at": "2025-01-27T12:00:00Z",
  "data": {
    "books": [...],
    "locations": [...],
    "ownerships": [...]
  }
}
```

### 2. 差分検出アルゴリズム

**Decision**: エンティティレベルでの差分検出を実装。書籍はISBN、場所は名前+タイプ、所有情報は(user_id, isbn, location_id)の組み合わせで識別する。

**Rationale**:
- ユーザーが理解しやすい粒度
- 実装がシンプルで保守しやすい
- パフォーマンスが良好（1000冊でも許容範囲内）

**Alternatives considered**:
- フィールドレベル: UXが複雑になり、実装コストが高い
- ハイブリッド: エンティティレベルで検出し、変更時のみフィールド詳細を表示する方式も検討したが、初期実装では不要と判断

**Implementation**:
1. インポートファイルの各エンティティを読み込む
2. データベースの対応するエンティティと比較
3. 追加（ファイルにのみ存在）、変更（両方に存在し値が異なる）、削除（DBにのみ存在）を分類
4. 差分をカテゴリ別に整理して返す

### 3. 場所マッチング戦略

**Decision**: 名前とタイプ（Physical/Digital）の組み合わせで既存の場所を検索。見つからない場合は新規作成する。

**Rationale**:
- 場所IDはユーザーごとに異なるため、IDベースのマッチングは不適切
- 名前とタイプの組み合わせは実用的で、ユーザーが理解しやすい
- 既存の場所が見つからない場合の処理が明確

**Alternatives considered**:
- IDベースのマッチング: 異なる環境間での移行時に機能しない
- ハイブリッド（ID→名前+タイプ）: 複雑さが増すだけでメリットが少ない

**Implementation**:
1. インポートファイルの各場所について、名前とタイプで既存の場所を検索
2. 見つかった場合はその場所IDを使用
3. 見つからない場合は新しい場所を作成し、新しい場所IDを使用
4. 所有情報の参照を更新

### 4. 大量データ処理のパフォーマンス

**Decision**: ストリーミング処理は不要。メモリ内で一括処理する。最大1000冊のデータはメモリに収まる。

**Rationale**:
- 1000冊の書籍データは約数MB程度で、Cloudflare Workersのメモリ制限内
- 一括処理の方が実装がシンプルで、トランザクション管理も容易
- パフォーマンス要件（3分以内）を満たせる

**Alternatives considered**:
- ストリーミング処理: 実装が複雑で、トランザクション管理が困難
- ページネーション: エクスポート/インポートでは不要（全データが必要）

**Implementation**:
- エクスポート: データベースから全データを取得し、JSONにシリアライズ
- インポート: JSONファイルをパースし、差分検出を実行後、一括でデータベースに反映

### 5. トランザクション管理

**Decision**: インポート処理全体を1つのトランザクションで実行する。エラーが発生した場合はロールバックする。

**Rationale**:
- データ整合性を保証するため
- 部分的なインポートはユーザーにとって混乱を招く
- D1はトランザクションをサポートしている

**Alternatives considered**:
- 部分的なコミット: データ整合性が損なわれる可能性がある
- バッチ処理: トランザクション管理が複雑になる

**Implementation**:
1. トランザクションを開始
2. ユーザーの選択に基づいてデータベースを更新
3. すべての更新が成功した場合のみコミット
4. エラーが発生した場合はロールバック

### 6. エラーハンドリング戦略

**Decision**: バリデーションエラーとデータ整合性エラーを分けて処理。バリデーションエラーは処理を中断し、データ整合性エラーは該当データをスキップして続行する。

**Rationale**:
- ファイル形式のエラーは早期に検出してユーザーに通知
- データ整合性エラー（参照先が存在しない等）は部分的なインポートを可能にする
- ユーザー体験を向上させる

**Alternatives considered**:
- すべてのエラーで処理を中断: 一部のデータが無効な場合に全体が失敗する
- すべてのエラーをスキップ: ファイル形式エラーも無視されてしまう

**Implementation**:
1. ファイル形式バリデーション: JSON形式、バージョン互換性をチェック（エラー時は処理中断）
2. データ整合性チェック: 書籍の存在確認、場所の参照確認（エラー時は該当データをスキップ）
3. エラーメッセージを日本語で統一

### 7. バージョン互換性

**Decision**: ファイル形式バージョンをメタデータに含め、現在のバージョンと互換性がない場合はエラーを返す。

**Rationale**:
- 将来のスキーマ変更に対応するため
- ユーザーに明確なエラーメッセージを提供
- 後方互換性の管理が容易

**Alternatives considered**:
- バージョンなし: 将来のスキーマ変更時に問題が発生
- 自動変換: 実装が複雑で、エラーが発生しやすい

**Implementation**:
- エクスポート時に現在のバージョン（"1.0"）をメタデータに含める
- インポート時にバージョンをチェックし、サポートされていない場合はエラーを返す
- 将来のバージョンアップ時は、マイグレーション関数を実装する可能性を考慮

## 実装パターン

### バックエンド

1. **ExportService**: 
   - ユーザーの全データ（書籍、場所、所有情報）を取得
   - JSON形式にシリアライズ
   - メタデータ（バージョン、エクスポート日時）を追加

2. **ImportService**:
   - JSONファイルをパース
   - バリデーション（形式、バージョン）
   - 差分検出（エンティティレベル）
   - 場所マッチング（名前+タイプ）
   - ユーザー選択に基づくデータベース更新（トランザクション内）

3. **API Routes**:
   - `GET /api/export?user_id=xxx`: エクスポートファイルをダウンロード
   - `POST /api/import?user_id=xxx`: インポートファイルをアップロード、差分検出結果を返す
   - `POST /api/import/apply?user_id=xxx`: ユーザーの選択に基づいてインポートを実行

### フロントエンド

1. **ExportButton**: エクスポート機能を実行するボタンコンポーネント
2. **ImportDialog**: 
   - ファイル選択
   - 差分可視化（追加、変更、削除をカテゴリ別に表示）
   - ユーザー選択（個別または一括）
   - インポート実行

3. **API Clients**:
   - `exportApi.export(userId)`: エクスポートファイルをダウンロード
   - `importApi.detectDiff(userId, file)`: 差分検出
   - `importApi.apply(userId, selections)`: インポート実行

## テスト戦略

1. **単体テスト**:
   - ExportService: データ取得、JSONシリアライズ
   - ImportService: 差分検出、場所マッチング、データ更新

2. **統合テスト**:
   - エクスポート→インポートの完全なフロー
   - 差分検出の正確性
   - エラーハンドリング

3. **パフォーマンステスト**:
   - 1000冊のデータでのエクスポート/インポート時間
   - 差分検出のパフォーマンス

## 依存関係

- 既存のサービス層（BookService, LocationService, OwnershipService）を再利用
- 既存のデータモデル（Book, Location, Ownership）をそのまま使用
- 新しい型定義（ExportData, ImportDifference）を追加

## 未解決事項

なし。すべての技術的な決定事項が明確になっている。

