# 開発ガイドライン

このドキュメントは、プロジェクトの初期実装から得られた重要な知見とベストプラクティスをまとめたものです。今後の開発の参考として活用してください。

## 目次

1. [プロジェクトセットアップ](#プロジェクトセットアップ)
2. [アーキテクチャパターン](#アーキテクチャパターン)
3. [MVP機能実装パターン](#mvp機能実装パターン)
4. [外部API統合](#外部api統合)
5. [エラーハンドリングとフォールバック](#エラーハンドリングとフォールバック)

---

## プロジェクトセットアップ

### プロジェクト構造の設計原則

**原則**: フロントエンドとバックエンドを明確に分離し、それぞれ独立して開発・テスト可能な構造にする。

```
プロジェクトルート/
├── backend/              # バックエンド（API）
│   ├── src/
│   │   ├── models/      # データモデル定義
│   │   ├── services/    # ビジネスロジック
│   │   ├── api/         # APIルーティング
│   │   │   ├── routes/  # エンドポイント定義
│   │   │   └── middleware/ # 共通ミドルウェア
│   │   └── types/       # TypeScript型定義
│   └── tests/           # バックエンドテスト
├── frontend/            # フロントエンド（UI）
│   ├── src/
│   │   ├── components/  # Reactコンポーネント
│   │   ├── pages/       # ページコンポーネント
│   │   ├── services/    # API呼び出しロジック
│   │   └── types/       # TypeScript型定義
│   └── tests/           # フロントエンドテスト
└── specs/               # 仕様・設計ドキュメント
```

**メリット**:
- フロントエンドとバックエンドを独立して開発可能
- テストが分離され、実行が容易
- チームの並行開発が可能
- デプロイメントの柔軟性

### 型安全性の確保

**原則**: フロントエンドとバックエンドで型定義を共有し、APIコントラクトの整合性を保つ。

**実装パターン**:
1. **共通型定義の配置**
   - バックエンド: `backend/src/types/index.ts`
   - フロントエンド: `frontend/src/types/index.ts`
   - 可能な限り型定義を一致させる

2. **APIレスポンス型の定義**
   ```typescript
   // バックエンド
   export interface Book {
     isbn: string
     title: string
     author: string | null
     // ...
   }

   // フロントエンド（同じ型を使用）
   import type { Book } from '../types'
   ```

3. **型生成の自動化**（将来対応）
   - OpenAPI仕様から型を自動生成
   - APIコントラクトの変更を型レベルで検出

### ミドルウェア設計パターン

**原則**: 共通処理はミドルウェアとして分離し、再利用性と保守性を確保する。

**必須ミドルウェア**:
1. **エラーハンドリング**
   - 統一されたエラーレスポンス形式
   - 適切なHTTPステータスコード
   - 日本語エラーメッセージ

2. **CORS設定**
   - 開発環境と本番環境で適切に設定
   - セキュリティを考慮したオリジン制限

3. **入力バリデーション**
   - リクエストボディの検証
   - 型安全性の確保
   - エラーメッセージの統一

4. **ロギング**
   - リクエスト/レスポンスのログ出力
   - エラー時の詳細ログ
   - 本番環境での適切なログレベル

5. **レート制限**（必要に応じて）
   - APIの過剰な呼び出しを防止
   - IPアドレスベースの制限

---

## アーキテクチャパターン

### エッジファーストアーキテクチャ

**原則**: ユーザーに最も近い場所（エッジ）で処理を実行し、レイテンシを最小化する。

**実装パターン**:
- すべてのアプリケーションロジックをエッジで実行
- データベースアクセスもエッジから直接
- グローバルに分散されたパフォーマンス

**メリット**:
- 低レイテンシ
- 高パフォーマンス
- スケーラビリティ
- 低コスト（エッジ実行の無料枠活用）

### サービス層パターン

**原則**: ビジネスロジックをサービス層に集約し、APIルートは薄く保つ。

**構造**:
```
backend/src/
├── api/routes/          # 薄いルーティング層
│   └── books.ts        # リクエスト/レスポンスの処理のみ
├── services/           # ビジネスロジック層
│   └── book_service.ts # データベース操作とビジネスルール
└── models/             # データモデル層
    └── book.ts         # データ構造とバリデーション
```

**メリット**:
- ビジネスロジックの再利用性
- テストの容易性
- 関心の分離

### データモデル設計

**原則**: 将来の拡張を見据えた設計を行い、MVP段階でもマルチユーザー対応の基盤を構築する。

**設計パターン**:
- ユーザーIDをすべてのテーブルに含める
- リレーショナル設計でデータの整合性を確保
- 外部キー制約を適切に設定
- インデックスを戦略的に配置

---

## MVP機能実装パターン

### 複数入力方法の統一インターフェース

**原則**: ユーザーに複数の入力方法を提供する場合、統一されたインターフェースで処理する。

**実装パターン**:
1. **入力方法の抽象化**
   - 各入力方法（キーワード検索、バーコードスキャン、手動入力）を独立したコンポーネントとして実装
   - 共通のデータ形式（例: `BookInput`）で統合

2. **フォールバック戦略**
   - 主要な入力方法が失敗した場合、代替方法を提示
   - ユーザー体験を損なわない設計

3. **状態管理**
   - 入力方法の切り替えを状態で管理
   - 各入力方法の状態を独立して管理

**例**:
```typescript
// 統一された入力インターフェース
interface BookInput {
  title: string
  author?: string
  isbn?: string
  thumbnail_url?: string
}

// 各入力方法から共通形式に変換
const normalizeInput = (source: 'search' | 'barcode' | 'manual', data: any): BookInput => {
  // 入力方法に応じて正規化
}
```

### 重複検出パターン

**原則**: データの重複を複数の基準で検出し、ユーザーに適切な選択肢を提示する。

**実装パターン**:
1. **複数基準での検出**
   - 主キー（例: ISBN）での検出
   - 複合キー（例: タイトル+著者）での検出

2. **ユーザーへの提示**
   - 重複検出時は既存データを表示
   - 「更新」または「新規登録」の選択肢を提供

3. **データ整合性の確保**
   - 重複チェックはデータベース制約と組み合わせ
   - レースコンディションへの対応

---

## 外部API統合

### 外部API統合の設計原則

**原則**: 外部APIへの依存を最小化し、失敗時のフォールバックを提供する。

**実装パターン**:
1. **サービス層での抽象化**
   ```typescript
   // 外部APIをサービスとして抽象化
   class ExternalAPIService {
     async search(query: string): Promise<Result[]>
     async getDetails(id: string): Promise<Details | null>
   }
   ```

2. **エラーハンドリング**
   - タイムアウトの設定
   - リトライロジック（必要に応じて）
   - フォールバック処理

3. **キャッシング**（将来対応）
   - 頻繁にアクセスするデータをキャッシュ
   - レート制限の回避

### 外部API統合の例

**Google Books API統合**:
- 書籍メタデータの取得
- 検索機能の提供
- 書影の取得

**実装のポイント**:
- APIキーの環境変数管理
- レスポンスの型定義
- エラー時の適切な処理
- 手動入力へのフォールバック

---

## エラーハンドリングとフォールバック

### エラーハンドリングの原則

**原則**: すべてのエラーを適切に処理し、ユーザーに分かりやすいメッセージを提供する。

**実装パターン**:
1. **統一されたエラーレスポンス**
   ```typescript
   interface ErrorResponse {
     error: {
       message: string
       code: string
     }
   }
   ```

2. **HTTPステータスコードの適切な使用**
   - 400: バリデーションエラー
   - 403: 所有権エラー
   - 404: リソース未存在
   - 409: 重複エラー
   - 500: サーバーエラー

3. **エラーメッセージの統一**
   - 日本語で統一
   - 技術的な詳細はログに記録
   - ユーザー向けメッセージは分かりやすく

### フォールバック戦略

**原則**: 主要な機能が失敗した場合でも、ユーザーが操作を続けられるようにする。

**実装パターン**:
1. **段階的なフォールバック**
   - 最適な方法 → 代替方法 → 手動入力
   - 例: バーコードスキャン → キーワード検索 → 手動入力

2. **部分的な成功の許容**
   - 一部の機能が失敗しても、他の機能は動作
   - 例: 書影の取得失敗でも書籍登録は可能

3. **ユーザーへの通知**
   - フォールバックが発生したことを通知
   - 代替方法を提示

---

## まとめ

これらのガイドラインは、プロジェクトの初期実装から得られた重要な知見をまとめたものです。今後の開発では、これらの原則に従うことで、一貫性のある高品質なコードを維持できます。

### 主要な原則の再確認

1. **型安全性**: フロントエンドとバックエンドで型定義を共有
2. **関心の分離**: サービス層、API層、モデル層を明確に分離
3. **エラーハンドリング**: 統一されたエラーレスポンスとフォールバック戦略
4. **ユーザー体験**: 複数の入力方法とフォールバックを提供
5. **保守性**: ミドルウェアとサービス層の再利用性

これらの原則を守ることで、スケーラブルで保守しやすいアプリケーションを構築できます。

